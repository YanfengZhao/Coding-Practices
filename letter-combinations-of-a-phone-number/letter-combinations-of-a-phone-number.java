/*
Given a digit string, return all possible letter combinations that the number could represent.

A mapping of digit to letters (just like on the telephone buttons) is given below.

Input:Digit string "23"
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
*/

// The key to this problem is to recognize that it's permutation.
// In the first iterative solution, every digit you add, number of output triples.
// This is because you add 3 possible letters to every possible solution generated by the last character

// In the second recursive solution, first create a global ArrayList of Strings as the result.
// Call the dfs helper recursive method passing in the digits and string in building progress (init "").
// Exit condition is when the length of the string you are trying to build is equal to number of digits.
// Find out what current digit you are on, and add 3 different characters corresponding to the digit by calling the recursive method 3 times in a loop
public class Solution {
    private static final String[] LETTERS = {
        "",       // 0
        "",       // 1
        "abc",    // 2
        "def",    // 3
        "ghi",    // 4
        "jkl",    // 5
        "mno",    // 6
        "pqrs",   // 7
        "tuv",    // 8
        "wxyz"   // 9
    };
    public List<String> letterCombinations(String digits) {
        ArrayList<String> result = new ArrayList<String>();
        result.add("");
        for(char c : digits.toCharArray()) {
            String letters = LETTERS[c-'0'];
            ArrayList<String> newResult = new ArrayList<String>();
            for(char l : letters.toCharArray())
                for(String s : result)
                    newResult.add(s + l);
            result = newResult;
        }
        return result;
    }
}

// recursion
public class Solution {
    public List<String> result = new ArrayList<String>();
    public String[] dict = {" ", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    public List<String> letterCombinations(String digits) {
        dfs(digits,"");
        return result;
    }
    
    public void dfs(String digits, String build){
        if(digits.length()==build.length()){
            if(build.length()>0)
                result.add(build);
            return;
        }
        int cur = build.length();
        int currDigit = digits.charAt(cur) - '0';
        String perm = dict[currDigit];
        for(int i = 0; i < perm.length(); i++){
            dfs(digits,build+perm.charAt(i));
        }
        return;
    }
}
